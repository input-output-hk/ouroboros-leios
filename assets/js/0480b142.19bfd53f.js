"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8070],{2453:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>d,contentTitle:()=>a,default:()=>c,frontMatter:()=>i,metadata:()=>r,toc:()=>l});var s=t(4848),n=t(8453);const i={sidebar_position:6},a="Ouroboros Leios FAQ",r={id:"faq",title:"Ouroboros Leios FAQ",description:"What are the benefits of Leios?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"How it works",permalink:"/docs/how-it-works"},next:{title:"Glossary",permalink:"/docs/glossary"}},d={},l=[{value:"What are the benefits of Leios?",id:"what-are-the-benefits-of-leios",level:2},{value:"What are downstream effects of deploying Leios?",id:"what-are-downstream-effects-of-deploying-leios",level:2},{value:"Could the mempool be sized to the throughput of the system?",id:"could-the-mempool-be-sized-to-the-throughput-of-the-system",level:2},{value:"Can the system be sharded according to resources (small nodes vs. big nodes)?",id:"can-the-system-be-sharded-according-to-resources-small-nodes-vs-big-nodes",level:2},{value:"Can the system self-regulate instead of manually fine tuning?",id:"can-the-system-self-regulate-instead-of-manually-fine-tuning",level:2}];function h(e){const o={h1:"h1",h2:"h2",p:"p",...(0,n.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(o.h1,{id:"ouroboros-leios-faq",children:"Ouroboros Leios FAQ"}),"\n",(0,s.jsx)(o.h2,{id:"what-are-the-benefits-of-leios",children:"What are the benefits of Leios?"}),"\n",(0,s.jsx)(o.p,{children:"Ouroboros Leios is a blockchain protocol that improves transaction throughput and\nlatency by using a pipelined endorsing process. Simply put, Leios is a way to\nprocess transactions faster."}),"\n",(0,s.jsx)(o.h2,{id:"what-are-downstream-effects-of-deploying-leios",children:"What are downstream effects of deploying Leios?"}),"\n",(0,s.jsx)(o.p,{children:"Ongoing internal discussions - we will publish an answer/link here to our\nfindings."}),"\n",(0,s.jsx)(o.h2,{id:"could-the-mempool-be-sized-to-the-throughput-of-the-system",children:"Could the mempool be sized to the throughput of the system?"}),"\n",(0,s.jsx)(o.p,{children:"That's already the case. Default mempool size is a small multiple of current\nblock size."}),"\n",(0,s.jsx)(o.h2,{id:"can-the-system-be-sharded-according-to-resources-small-nodes-vs-big-nodes",children:"Can the system be sharded according to resources (small nodes vs. big nodes)?"}),"\n",(0,s.jsx)(o.p,{children:"Leios' current design does not involve sharding in a sense of different resource\nrequirements for different nodes. In short, the Leios design does not involve\nsharding. These are ideas in research and require more work. As of now, each\nnode has to validate all blocks, hence in a traditional sense, adding more nodes\ndoes not increase throughput. Each node must cope with the throughput of the\nwhole system."}),"\n",(0,s.jsx)(o.h2,{id:"can-the-system-self-regulate-instead-of-manually-fine-tuning",children:"Can the system self-regulate instead of manually fine tuning?"}),"\n",(0,s.jsx)(o.p,{children:"The current system's load is imposed on each node through the protocol\nparameters. Thus, it remains a democratic vote, not a choice made locally by\nnodes or automatically. Given that the load is imposed on each node through the\nchoice of the protocol parameters, it remains a democratic vote to drive\nadaptation. In a sharded approach this could be different. But in the current\nsystem there is no local or automatic choice to be made by individual nodes."})]})}function c(e={}){const{wrapper:o}={...(0,n.R)(),...e.components};return o?(0,s.jsx)(o,{...e,children:(0,s.jsx)(h,{...e})}):h(e)}},8453:(e,o,t)=>{t.d(o,{R:()=>a,x:()=>r});var s=t(6540);const n={},i=s.createContext(n);function a(e){const o=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(o):{...o,...e}}),[o,e])}function r(e){let o;return o=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:a(e.components),s.createElement(i.Provider,{value:o},e.children)}}}]);