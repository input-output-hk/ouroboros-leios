"use strict";(self.webpackChunksite=self.webpackChunksite||[]).push([[8070],{2453:(e,s,o)=>{o.r(s),o.d(s,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>t,metadata:()=>a,toc:()=>d});var n=o(4848),i=o(8453);const t={sidebar_position:6},r="FAQs",a={id:"faq",title:"FAQs",description:"What is Ouroboros Leios?",source:"@site/docs/faq.md",sourceDirName:".",slug:"/faq",permalink:"/docs/faq",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"How it works",permalink:"/docs/how-it-works"},next:{title:"Glossary",permalink:"/docs/glossary"}},l={},d=[{value:"What is Ouroboros Leios?",id:"what-is-ouroboros-leios",level:2},{value:"What are the key benefits of Leios over other Ouroboros protocols?",id:"what-are-the-key-benefits-of-leios-over-other-ouroboros-protocols",level:2},{value:"What are IBs, EBs, and RBs in Leios?",id:"what-are-ibs-ebs-and-rbs-in-leios",level:2},{value:"How does Leios handle voting stages, and what is &#39;send-recv&#39; voting?",id:"how-does-leios-handle-voting-stages-and-what-is-send-recv-voting",level:2},{value:"What is sortition in Leios, and how does &#39;Fait Accompli sortition&#39; work?",id:"what-is-sortition-in-leios-and-how-does-fait-accompli-sortition-work",level:2},{value:"What are the different block diffusion strategies, and why do they matter?",id:"what-are-the-different-block-diffusion-strategies-and-why-do-they-matter",level:2},{value:"Can the system be sharded or self-regulated?",id:"can-the-system-be-sharded-or-self-regulated",level:2},{value:"What improvements in cryptography are used in Leios?",id:"what-improvements-in-cryptography-are-used-in-leios",level:2},{value:"How do I estimate node operating costs for Leios?",id:"how-do-i-estimate-node-operating-costs-for-leios",level:2},{value:"What is the current status of Leios simulations?",id:"what-is-the-current-status-of-leios-simulations",level:2},{value:"Are there recommended parameters for running Leios nodes?",id:"are-there-recommended-parameters-for-running-leios-nodes",level:2},{value:"How do I keep track of Leios&#39;s progress and updates?",id:"how-do-i-keep-track-of-leioss-progress-and-updates",level:2},{value:"What are the downstream effects of deploying Leios?",id:"what-are-the-downstream-effects-of-deploying-leios",level:2},{value:"Could the mempool be sized according to the system&#39;s throughput?",id:"could-the-mempool-be-sized-according-to-the-systems-throughput",level:2},{value:"Is Leios production-ready?",id:"is-leios-production-ready",level:2}];function c(e){const s={h1:"h1",h2:"h2",li:"li",p:"p",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.h1,{id:"faqs",children:"FAQs"}),"\n",(0,n.jsx)(s.h2,{id:"what-is-ouroboros-leios",children:"What is Ouroboros Leios?"}),"\n",(0,n.jsx)(s.p,{children:"Ouroboros Leios is a next-generation blockchain consensus protocol designed to improve transaction throughput and reduce latency by using a pipelined endorsing process. It builds upon the core Ouroboros principles (as used by Cardano), introducing separate input blocks (IBs) for transactions and endorser blocks (EBs) that reference those transactions, thus enhancing scalability."}),"\n",(0,n.jsx)(s.h2,{id:"what-are-the-key-benefits-of-leios-over-other-ouroboros-protocols",children:"What are the key benefits of Leios over other Ouroboros protocols?"}),"\n",(0,n.jsx)(s.p,{children:"Leios offers several significant advantages:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Higher throughput and lower latency."})," By splitting transaction processing into IB and EB stages, Leios handles more transactions in parallel."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Flexible diffusion strategies."})," Nodes can choose different block-propagation methods, such as 'freshest-first' or 'oldest-first.'"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Enhanced cryptography."})," Leios uses Boneh\u2013Lynn\u2013Shacham (BLS) signatures for aggregated verification and verifiable random functions (VRFs) for leader selection."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Robust simulations and formal methods."})," Rust and Haskell simulations measure real-world performance, and executable specifications help ensure correctness."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Scalable cost model."})," A cost calculator enables node operators to estimate expenses (for example, storage amortization and CPU usage)."]}),"\n"]}),"\n",(0,n.jsx)(s.h2,{id:"what-are-ibs-ebs-and-rbs-in-leios",children:"What are IBs, EBs, and RBs in Leios?"}),"\n",(0,n.jsx)(s.p,{children:"Leios uses three distinct block types:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"IB (input block):"})," a block that contains transactions. Produced by nodes that win the IB sortition lottery."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"EB (endorser block):"})," a block that references one or more IBs, providing endorsements. Produced by nodes that win the EB sortition lottery."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"RB (ranking block):"})," a block that ranks or orders other blocks as part of the consensus mechanism."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Each block type plays a distinct role in moving transactions from submission to final confirmation."}),"\n",(0,n.jsx)(s.h2,{id:"how-does-leios-handle-voting-stages-and-what-is-send-recv-voting",children:"How does Leios handle voting stages, and what is 'send-recv' voting?"}),"\n",(0,n.jsx)(s.p,{children:"Leios finalizes blocks through a structured voting mechanism. Nodes may adopt:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Single-stage voting:"})," all votes are broadcast in one phase, possibly resulting in a longer CPU usage 'tail' during high throughput."]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Send-recv (two-stage) voting:"})," votes are first sent, then a follow-up receive phase ensures broader propagation before final tallies."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"You can configure voting through parameters such as leios-vote-send-recv-stages in simulation environments."}),"\n",(0,n.jsx)(s.h2,{id:"what-is-sortition-in-leios-and-how-does-fait-accompli-sortition-work",children:"What is sortition in Leios, and how does 'Fait Accompli sortition' work?"}),"\n",(0,n.jsx)(s.p,{children:"Sortition is a probabilistic method for selecting nodes (based on stake) to produce blocks or issue votes. In Leios, it is referred to as 'Fait Accompli sortition' because once a node proves it was selected to produce a block or vote (using a cryptographic proof), no conflicting claims can arise."}),"\n",(0,n.jsx)(s.h2,{id:"what-are-the-different-block-diffusion-strategies-and-why-do-they-matter",children:"What are the different block diffusion strategies, and why do they matter?"}),"\n",(0,n.jsx)(s.p,{children:"Leios supports multiple strategies for propagating blocks and votes:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Oldest-first:"})," prioritizes older blocks or transactions"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Freshest-first:"})," focuses on the newest blocks or transactions first"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Peer-order:"})," requests blocks in the order peers announce them."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Your choice of strategy can affect latency, network load, and overall throughput."}),"\n",(0,n.jsx)(s.h2,{id:"can-the-system-be-sharded-or-self-regulated",children:"Can the system be sharded or self-regulated?"}),"\n",(0,n.jsx)(s.p,{children:"Not in its current design. Every node validates the entire chain. Thus, adding more nodes does not inherently increase throughput in the same way sharded protocols do. The community votes on protocol parameters (for example, block size), and the system's load is the same for all. Future research may explore sharding, but it is not yet part of Leios."}),"\n",(0,n.jsx)(s.h2,{id:"what-improvements-in-cryptography-are-used-in-leios",children:"What improvements in cryptography are used in Leios?"}),"\n",(0,n.jsx)(s.p,{children:"Leios incorporates multiple cryptographic techniques to ensure security and efficiency:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"BLS signatures: allows efficient aggregation of many signatures into one, reducing verification overhead"}),"\n",(0,n.jsx)(s.li,{children:"Mithril or Musen protocols: used for voting and proof aggregation, depending on the context"}),"\n",(0,n.jsx)(s.li,{children:"VRFs: ensures fair selection of nodes for block production"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Recent benchmarking shows that aggregated BLS verification significantly speeds up certificate validation."}),"\n",(0,n.jsx)(s.h2,{id:"how-do-i-estimate-node-operating-costs-for-leios",children:"How do I estimate node operating costs for Leios?"}),"\n",(0,n.jsx)(s.p,{children:"Leios provides an online cost calculator that considers:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:"CPU usage and the number of cores"})}),"\n",(0,n.jsx)(s.li,{children:(0,n.jsx)(s.strong,{children:"Bandwidth consumption"})}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Storage"})," (including the default assumption of 50% disk compression)"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Perpetual storage cost amortization"}),"."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"It also supports hyperscale and discount cloud providers. For example, you can model single-relay or multi-relay deployments at variable bandwidths."}),"\n",(0,n.jsx)(s.h2,{id:"what-is-the-current-status-of-leios-simulations",children:"What is the current status of Leios simulations?"}),"\n",(0,n.jsx)(s.p,{children:"Two primary simulation frameworks (Rust and Haskell) are maintained to:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Test network topologies and measure real or simulated latencies (using the DeltaQ model)"}),"\n",(0,n.jsx)(s.li,{children:"Evaluate CPU usage for blocks and transactions under varying loads"}),"\n",(0,n.jsx)(s.li,{children:"Visualize block diffusion (IBs, EBs, and RBs) using different strategies"}),"\n",(0,n.jsx)(s.li,{children:"Compare ideal conditions vs realistic mainnet-like topologies."}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Developers continually refine these simulations based on real-world data."}),"\n",(0,n.jsx)(s.h2,{id:"are-there-recommended-parameters-for-running-leios-nodes",children:"Are there recommended parameters for running Leios nodes?"}),"\n",(0,n.jsx)(s.p,{children:"Based on preliminary internal testing and simulations:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Block size:"})," commonly set to about one-third of the available link capacity for IBs"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Voting stages:"})," choose single-stage or send-recv, depending on reliability and speed requirements"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Diffusion strategy:"})," many operators use 'freshest-first,' though 'peer-order' may help maintain compatibility with older setups."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Operators can adjust these parameters, which evolve through community votes."}),"\n",(0,n.jsx)(s.h2,{id:"how-do-i-keep-track-of-leioss-progress-and-updates",children:"How do I keep track of Leios's progress and updates?"}),"\n",(0,n.jsx)(s.p,{children:"You can follow:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsx)(s.li,{children:"Weekly progress updates on the Ouroboros Leios site"}),"\n",(0,n.jsx)(s.li,{children:"Technical reports for deeper insights"}),"\n",(0,n.jsx)(s.li,{children:"Leios glossary for definitions of commonly used terms"}),"\n",(0,n.jsx)(s.li,{children:"Public GitHub repositories that host source code and simulations"}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"These resources provide transparency and regular updates on ongoing development."}),"\n",(0,n.jsx)(s.h2,{id:"what-are-the-downstream-effects-of-deploying-leios",children:"What are the downstream effects of deploying Leios?"}),"\n",(0,n.jsx)(s.p,{children:"Leios changes how transactions are validated and how blocks and memory pools operate, potentially affecting:"}),"\n",(0,n.jsxs)(s.ul,{children:["\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Wallets and SDKs,"})," which need to accommodate new block types (IBs and EBs)"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Explorers,"})," which must handle higher throughput and multi-block referencing"]}),"\n",(0,n.jsxs)(s.li,{children:[(0,n.jsx)(s.strong,{children:"Indexers and APIs,"})," which will see more granular block and vote data."]}),"\n"]}),"\n",(0,n.jsx)(s.p,{children:"Weekly progress updates provide a deeper analysis of these topics, including how advanced indexing and potential sharding solutions might eventually mitigate challenges."}),"\n",(0,n.jsx)(s.h2,{id:"could-the-mempool-be-sized-according-to-the-systems-throughput",children:"Could the mempool be sized according to the system's throughput?"}),"\n",(0,n.jsx)(s.p,{children:"That's already the case. The default mempool size is a small multiple of the current block size."}),"\n",(0,n.jsx)(s.h2,{id:"is-leios-production-ready",children:"Is Leios production-ready?"}),"\n",(0,n.jsx)(s.p,{children:"Leios remains an active research and development protocol. It is backed by a robust formal methods framework and two major simulation environments. However, it has not reached full production status. Watch the official progress updates and technical reports for major release announcements."})]})}function h(e={}){const{wrapper:s}={...(0,i.R)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},8453:(e,s,o)=>{o.d(s,{R:()=>r,x:()=>a});var n=o(6540);const i={},t=n.createContext(i);function r(e){const s=n.useContext(t);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(t.Provider,{value:s},e.children)}}}]);